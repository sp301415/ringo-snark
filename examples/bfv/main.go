package main

import (
	"fmt"
	"math"
	"math/big"
	"time"

	"github.com/sp301415/cyclone/bigring"
	"github.com/sp301415/cyclone/buckler"
	"github.com/sp301415/cyclone/celpc"
	"github.com/tuneinsight/lattigo/v6/core/rlwe"
	"github.com/tuneinsight/lattigo/v6/schemes/bgv"
)

// In this example, we show how to prove the well-formedness of
// BFV ciphertext generated by lattigo.
//
// Simply, put, for a ciphertext (c0 = -c1*s + (q/t)*m + e, c1), we should prove:
//
// c0 = -c1*s + (q/t)*m + e
// |m| < t
// |e| <= B_e
//
// Where t is the plaintext modulus and B_e is the error bound.
// In our example, we set t = 2^16 + 1.

type CiphertextCircuit struct {
	Degree           int
	PlaintextModulus uint64
	ErrBound         uint64

	CiphertextNTT [2]buckler.PublicWitness

	SecretKeyNTT buckler.Witness

	Delta         *big.Int
	MessageNTT    buckler.Witness
	MessageCoeffs buckler.Witness

	ErrorNTT    buckler.Witness
	ErrorCoeffs buckler.Witness
}

func (c *CiphertextCircuit) Define(ctx *buckler.Context) {
	ctx.AddNTTConstraint(c.MessageCoeffs, c.MessageNTT)
	ctx.AddNTTConstraint(c.ErrorCoeffs, c.ErrorNTT)

	// Body + Mask * sk - Message - Error = 0
	var ctCircuit buckler.ArithmeticConstraint
	ctCircuit.AddTerm(big.NewInt(1), c.CiphertextNTT[0])
	ctCircuit.AddTerm(big.NewInt(1), c.CiphertextNTT[1], c.SecretKeyNTT)
	ctCircuit.AddTerm(big.NewInt(0).Neg(c.Delta), nil, c.MessageNTT)
	ctCircuit.AddTerm(big.NewInt(-1), nil, c.ErrorNTT)
	ctx.AddArithmeticConstraint(ctCircuit)

	// |m| < t
	ctx.AddInfNormConstraint(c.MessageCoeffs, c.PlaintextModulus-1)
	// |e| <= B_e
	ctx.AddInfNormConstraint(c.ErrorCoeffs, c.ErrBound)
}

// A common problem of using zk-SNARKs is the mismatch between the constraint space and the proof space.
// Unfortunately, Buckler is not an exception.
// In typical BFV implementations, we use "RNS q", which is a product of word-size primes.
// However, in Buckler, q must be a single, large prime.
//
// To solve this problem, we use modulus switching.
// To be precise, there are two ways.
//
// First way is to generate a ciphertext in RNS q, modulus switch to Buckler q,
// and generate the proof.
// This way, the error bound of fresh ciphertext would be larger,
// so proof size and time would be larger.
//
// Second way is to generate a ciphertext in Buckler q, generate the proof,
// and then modulus switch to RNS q.
// This method has no proof overhead but you should write your own BFV encryption implementation.
//
// In this example, we use the first way.

func main() {
	celpcParamsLogN13LogQ212 := celpc.ParametersLiteral{
		AjtaiSize:     1,
		AjtaiRandSize: 1 + 1,

		Degree:           1 << 13,
		BigIntCommitSize: 1 << 11,

		ModulusBase: 9694,
		Digits:      16,

		RingDegree:     1 << 11,
		LogRingModulus: []int{55, 55},

		CommitStdDev:       10,
		OpeningProofStdDev: 32,
		BlindStdDev:        math.Exp2(19),

		CommitRandStdDev:       20,
		OpeningProofRandStdDev: 64,
		BlindRandStdDev:        math.Exp2(20),

		OpenProofBound: math.Exp2(32.754070623437386),
		EvalBound:      math.Exp2(48.75847312606874),
	}.Compile()

	bfvParamsLiteralLogN13LogQ240 := bgv.ParametersLiteral{
		LogN:             13,
		LogQ:             []int{60, 60, 60, 60},
		PlaintextModulus: (1 << 16) + 1,
	}
	bfvParamsLogN13LogQ240, err := bgv.NewParametersFromLiteral(bfvParamsLiteralLogN13LogQ240)
	if err != nil {
		panic(err)
	}
	ringT := bfvParamsLogN13LogQ240.RingT()
	ringQ := bfvParamsLogN13LogQ240.RingQ()

	// Generate BFV encryption using lattigo.
	keyGen := bgv.NewKeyGenerator(bfvParamsLogN13LogQ240)
	sk := keyGen.GenSecretKeyNew()

	ecd := bgv.NewEncoder(bfvParamsLogN13LogQ240)
	ptT := bfvParamsLogN13LogQ240.RingT().NewPoly()
	ecd.EncodeRingT([]uint64{1, 2, 3, 4}, rlwe.NewScale(1), ptT)
	ptQ := rlwe.NewPlaintext(bfvParamsLogN13LogQ240, bfvParamsLogN13LogQ240.MaxLevel())
	ecd.RingT2Q(bfvParamsLogN13LogQ240.MaxLevel(), true, ptT, ptQ.Value)
	ringQ.NTT(ptQ.Value, ptQ.Value)

	enc := bgv.NewEncryptor(bfvParamsLogN13LogQ240, sk)
	ct, _ := enc.EncryptNew(ptQ)

	// Modulus switch to Buckler q.
	// Note that modulus switching should be done in coefficient representation,
	// So we start by converting them.
	// sk, by default, is in montgomery representation.
	ringQ.IMForm(sk.Value.Q, sk.Value.Q)
	ringQ.INTT(sk.Value.Q, sk.Value.Q)

	// ptT is already in coefficient representation.

	ringQ.INTT(ct.Value[0], ct.Value[0])
	ringQ.INTT(ct.Value[1], ct.Value[1])

	// sk lives in R, so we can simply move it to big.Int.
	bigringQ := bigring.NewBigRing(celpcParamsLogN13LogQ212.Degree(), celpcParamsLogN13LogQ212.Modulus())
	skCoeffs := bigringQ.NewPoly()
	ringQ.PolyToBigintCentered(sk.Value.Q, 1, skCoeffs.Coeffs)
	skNTT := bigringQ.ToNTTPoly(skCoeffs)

	// ptT lives in R_t, so again we simply move it to big.Int.
	ptCoeffs := bigringQ.NewPoly()
	ringT.PolyToBigintCentered(ptT, 1, ptCoeffs.Coeffs)
	ptNTT := bigringQ.ToNTTPoly(ptCoeffs)

	// Finally, we modulus switch the ciphertext.
	ctCoeffs := [2]bigring.BigPoly{bigringQ.NewPoly(), bigringQ.NewPoly()}
	ringQ.PolyToBigintCentered(ct.Value[0], 1, ctCoeffs[0].Coeffs)
	ringQ.PolyToBigintCentered(ct.Value[1], 1, ctCoeffs[1].Coeffs)
	for i := 0; i < bigringQ.Degree(); i++ {
		ctCoeffs[0].Coeffs[i].Mul(ctCoeffs[0].Coeffs[i], bigringQ.Modulus())
		ctCoeffs[0].Coeffs[i].Div(ctCoeffs[0].Coeffs[i], ringQ.Modulus())

		ctCoeffs[1].Coeffs[i].Mul(ctCoeffs[1].Coeffs[i], bigringQ.Modulus())
		ctCoeffs[1].Coeffs[i].Div(ctCoeffs[1].Coeffs[i], ringQ.Modulus())
	}
	ctNTT := [2]bigring.BigNTTPoly{bigringQ.ToNTTPoly(ctCoeffs[0]), bigringQ.ToNTTPoly(ctCoeffs[1])}

	// We need to recompute the error so that we can generate aritmetic contraints.
	// Recall that c0 = -c1*s + (q/t)*m + e.
	// So, e = c0 + c1*s - (q/t)*m.
	delta := big.NewInt(0).ModInverse(ringT.Modulus(), ringQ.Modulus())
	// We also modulus switch the scaling factor.
	delta.Mul(delta, bigringQ.Modulus())
	delta.Div(delta, ringQ.Modulus())

	errNTT := bigringQ.NewNTTPoly()
	bigringQ.MulNTTAssign(ctNTT[1], skNTT, errNTT)
	bigringQ.AddNTTAssign(errNTT, ctNTT[0], errNTT)
	bigringQ.ScalarMulSubNTTAssign(ptNTT, delta, errNTT)
	errCoeffs := bigringQ.ToPoly(errNTT)

	// After modulus switching, the existing error is replaced by the rounding error,
	// which has infinity norm ~ t + N.
	errBound := uint64(bfvParamsLogN13LogQ240.N()) + bfvParamsLogN13LogQ240.PlaintextModulus()

	// Now we are ready to generate the proof.
	c := CiphertextCircuit{
		// All non-witness fields should be set for correct compilation.
		Degree:           bfvParamsLogN13LogQ240.N(),
		PlaintextModulus: bfvParamsLogN13LogQ240.PlaintextModulus(),
		Delta:            delta,
		ErrBound:         errBound,
	}
	prover, verifier, err := buckler.Compile(celpcParamsLogN13LogQ212, &c)
	if err != nil {
		panic(err)
	}
	ck := celpc.GenAjtaiCommitKey(celpcParamsLogN13LogQ212)

	assignment := CiphertextCircuit{
		Degree:           c.Degree,
		PlaintextModulus: c.PlaintextModulus,

		CiphertextNTT: [2]buckler.PublicWitness{ctNTT[0].Coeffs, ctNTT[1].Coeffs},

		SecretKeyNTT: skNTT.Coeffs,

		Delta:         delta,
		MessageNTT:    ptNTT.Coeffs,
		MessageCoeffs: ptCoeffs.Coeffs,

		ErrBound:    errBound,
		ErrorNTT:    errNTT.Coeffs,
		ErrorCoeffs: errCoeffs.Coeffs,
	}

	now := time.Now()
	pf, err := prover.Prove(ck, &assignment)
	fmt.Println("Prover time:", time.Since(now))
	if err != nil {
		panic(err)
	}

	now = time.Now()
	vf := verifier.Verify(ck, pf)
	fmt.Println("Verifier time:", time.Since(now))
	fmt.Println("Verification result:", vf)
}
